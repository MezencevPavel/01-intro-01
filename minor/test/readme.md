### Техническое задание : 
Не ожидаем production-ready решения. Сделайте, как кажется правильным, опишите процесс поиска и принятые решения.  
  
Опишите решение для веб-приложения в kubernetes в виде yaml-манифеста. Оставляйте в коде комментарии по принятым решениям. Есть следующие вводные:  
<br>

---

1. у нас мультизональный кластер (три зоны), в котором пять нод  
2. приложение требует около 5-10 секунд для инициализации  
3. по результатам нагрузочного теста известно, что 4 пода справляются с пиковой нагрузкой  
4. на первые запросы приложению требуется значительно больше ресурсов CPU, в дальнейшем потребление ровное в районе 0.1 CPU. По памяти  всегда “ровно” в районе 128M memory  
5. приложение имеет дневной цикл по нагрузке – ночью запросов на порядки меньше, пик – днём  
6. хотим максимально отказоустойчивый deployment  
7. хотим минимального потребления ресурсов от этого deployment’а  

--- 
<br>  

Использовать мы будем следующие объекты **kubernetess**:  
  
[**Deployment**](https://github.com/MezencevPavel/devops-netology/blob/main/minor/test/deploy.yml) - это объект Kubernetes, который используется для управления развертыванием и масштабированием приложений. Он обеспечивает декларативное управление состоянием приложения, автоматически создавая и обновляя поды.  
[**Service**](https://github.com/MezencevPavel/devops-netology/blob/main/minor/test/service.yml) - то объект **Kubernetes**, который предоставляет стабильный сетевой интерфейс для набора подов. Он позволяет подключаться к подам, даже если они перезапускаются или перемещаются между нодами  
[**HorizontalPodAutoscaler**](https://github.com/MezencevPavel/devops-netology/blob/main/minor/test/HApid.yml) - это компонент **Kubernetes**, который автоматически масштабирует количество подов в деплойменте, репликасете или statefullset на основе метрик, таких как использование CPU, памяти или пользовательских метрик. HPA позволяет динамически изменять количество подов в ответ на изменения нагрузки, обеспечивая оптимальное использование ресурсов и высокую доступность приложения.  
  
1. Для мультизональности мы будем использовать механизм **podAntiAffinity**. podAntiAffinity  позволяет управлять распределением подов по нодам кластера. Он используется для предотвращения размещения подов с одинаковыми метками на одной и той же ноде или в одной и той же зоне доступности. Это помогает повысить отказоустойчивость и устойчивость приложения к сбоям.  
  
```markdown
 affinity:
        podAntiAffinity: 
          requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchExpressions:
              - key: app
                operator: In
                values:
                - my-web-app
            topologyKey: "kubernetes.io/hostname"
```

**labelSelector** -  Определяет условия для выбора подов по меткам.  
**topologyKey: kubernetes.io/hostname** - это настройка, которая говорит Kubernetes, что поды (контейнеры) должны быть распределены по разным нодам (серверам) в кластере.


2. Приложение требует 5-10 секунд для инициализации. Используем **readinessProbe** -  это механизм в Kubernetes, который используется для определения, готов ли под принимать трафик.  

```markdown
        readinessProbe:
          httpGet:
            path: /replace 
            port: 80
          initialDelaySeconds: 10 
          periodSeconds: 5 
```
**initialDelaySeconds** - Задержка перед первой проверкой готовности. Это время дается под на инициализацию приложения, в данном случае 10 секунд.  
**periodSeconds** - Периодичность проверок готовности. Это интервал времени между проверками. В данном случае 5 секунд.  
  
3. Мы установили начальное количество реплик в деплойменте на 4, чтобы соответствовать результатам нагрузочного теста.
```markdown
spec:
  replicas: 4
```
4. Ресурсы (resources) мы указали в [**deployment**](),  
```markdown
    spec:
      containers:
      - name: my-web-app
        image: my-web-app-image:latest # используем наш образ, например nginx
        resources:
          requests:
            memory: "128Mi" # Минимальное потребление памяти
            cpu: "100m" # Минимальное потребление CPU
          limits:
            memory: "256Mi" # Лимит памяти для обработки пиковых нагрузок
            cpu: "500m" # Лимит CPU для обработки пиковых нагрузок
```
  
5. в [HorizontalPodAutoscaler](https://github.com/MezencevPavel/devops-netology/blob/main/minor/test/HApid.yml) мы указали что минимальное количество реплик, для работы ночью и максимальное, для пиковых нагрузок днём.  
Так же мы указали метрику, на основе которой будет происходить масштабирование. В данном случае используется метрика использования CPU с целевым значением 50%  
```markdown
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: my-web-app
  minReplicas: 2 # Минимальное количество реплик для ночного времени
  maxReplicas: 8 # Максимальное количество реплик для пиковой нагрузки
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 50 # Целевое использование CPU для масштабирования
```
  6. Для максимальной отказоустойчевости мы использовали:  
  **readinessProbe** -  позволяет Kubernetes определить, готов ли под принимать трафик.    
  **livenessProbe** -  позволяет Kubernetes определить, жив ли под. Если под не жив, Kubernetes перезапустит его.  
  **HorizontalPodAutoscaler** - HPA автоматически масштабирует количество подов в зависимости от нагрузки  
  **Мультизональный кластер** -  Мультизональный кластер помогает обеспечить высокую доступность и отказоустойчивость, так как поды могут быть распределены по разным зонам доступности  

  7.  Для минимального потребления мы указали минимальные значения для CPU и памяти, а так же указали максимальные значения для CPU и памяти для стабильности работы приложения.

